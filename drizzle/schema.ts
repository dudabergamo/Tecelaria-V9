import { int, mysqlEnum, mysqlTable, text, timestamp, varchar, boolean, date } from "drizzle-orm/mysql-core";

/**
 * Core user table backing auth flow.
 */
export const users = mysqlTable("users", {
  id: int("id").autoincrement().primaryKey(),
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),
  
  // Tecelaria specific fields
  phone: varchar("phone", { length: 20 }),
  address: text("address"),
  cep: varchar("cep", { length: 10 }),
  cpf: varchar("cpf", { length: 14 }),
  identityDocument: varchar("identityDocument", { length: 20 }),
  birthDate: date("birthDate"),
  password: varchar("password", { length: 255 }), // hashed password
  profilePictureUrl: text("profilePictureUrl"),
  kitActivatedAt: timestamp("kitActivatedAt"),
  memoryPeriodEndDate: timestamp("memoryPeriodEndDate"), // 3 meses para enviar memórias
  bookFinalizationEndDate: timestamp("bookFinalizationEndDate"), // 1 ano para finalizar livro
  programEndDate: timestamp("programEndDate"), // deprecated, manter por compatibilidade
  lastUploadDate: timestamp("lastUploadDate"),
  bookProcessingStarted: boolean("bookProcessingStarted").default(false).notNull(),
  bookReadyForReview: boolean("bookReadyForReview").default(false).notNull(),
  bookApproved: boolean("bookApproved").default(false).notNull(),
  customMemoryCount: int("customMemoryCount").default(0).notNull(),
  
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

/**
 * Memory categories (predefined + custom)
 */
export const memoryCategories = mysqlTable("memory_categories", {
  id: int("id").autoincrement().primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  isPredefined: boolean("isPredefined").default(false).notNull(),
  order: int("order").default(0).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type MemoryCategory = typeof memoryCategories.$inferSelect;
export type InsertMemoryCategory = typeof memoryCategories.$inferInsert;

/**
 * Memories (mini-projects)
 */
export const memories = mysqlTable("memories", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  categoryId: int("categoryId").notNull(),
  questionId: int("questionId"), // ID da pergunta da caixinha (se respondeu uma pergunta específica)
  title: text("title").notNull(),
  summary: text("summary"),
  themes: text("themes"), // JSON array stored as text
  peopleMentioned: text("peopleMentioned"), // JSON array stored as text
  periodMentioned: varchar("periodMentioned", { length: 100 }),
  processed: boolean("processed").default(false).notNull(),
  version: int("version").default(1).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Memory = typeof memories.$inferSelect;
export type InsertMemory = typeof memories.$inferInsert;

/**
 * Memory records (individual audio/text/photo entries within a memory)
 */
export const memoryRecords = mysqlTable("memory_records", {
  id: int("id").autoincrement().primaryKey(),
  memoryId: int("memoryId").notNull(),
  userId: int("userId").notNull(),
  content: text("content"), // transcription or text content
  type: mysqlEnum("type", ["audio", "text", "document", "photo"]).notNull(),
  fileUrl: text("fileUrl"),
  fileKey: text("fileKey"),
  fileName: varchar("fileName", { length: 255 }),
  fileSize: int("fileSize"), // in bytes
  mimeType: varchar("mimeType", { length: 100 }),
  order: int("order").default(0).notNull(),
  addedAt: timestamp("addedAt").defaultNow().notNull(),
});

export type MemoryRecord = typeof memoryRecords.$inferSelect;
export type InsertMemoryRecord = typeof memoryRecords.$inferInsert;

/**
 * Follow-up questions generated by AI
 */
export const followupQuestions = mysqlTable("followup_questions", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  memoryId: int("memoryId"),
  categoryId: int("categoryId"),
  question: text("question").notNull(),
  sentAt: timestamp("sentAt").defaultNow().notNull(),
  answered: boolean("answered").default(false).notNull(),
  answerMemoryId: int("answerMemoryId"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type FollowupQuestion = typeof followupQuestions.$inferSelect;
export type InsertFollowupQuestion = typeof followupQuestions.$inferInsert;

/**
 * Book metadata
 */
export const bookMetadata = mysqlTable("book_metadata", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().unique(),
  bookTitle: text("bookTitle"),
  totalPages: int("totalPages").default(0).notNull(),
  totalWords: int("totalWords").default(0).notNull(),
  totalImages: int("totalImages").default(0).notNull(),
  pdfUrl: text("pdfUrl"), // preview PDF
  finalPdfUrl: text("finalPdfUrl"), // approved version
  userFeedback: text("userFeedback"),
  status: mysqlEnum("status", ["processing", "ready_for_review", "approved", "sent_to_print"]).default("processing").notNull(),
  organizationType: mysqlEnum("organizationType", ["chronological", "thematic"]),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BookMetadata = typeof bookMetadata.$inferSelect;
export type InsertBookMetadata = typeof bookMetadata.$inferInsert;

/**
 * Book chapters
 */
export const bookChapters = mysqlTable("book_chapters", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull(),
  bookId: int("bookId").notNull(),
  chapterNumber: int("chapterNumber").notNull(),
  chapterTitle: text("chapterTitle").notNull(),
  content: text("content").notNull(), // markdown formatted
  memoriesIncluded: text("memoriesIncluded"), // JSON array of memory IDs
  photosIncluded: text("photosIncluded"), // JSON array of photo IDs
  wordCount: int("wordCount").default(0).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BookChapter = typeof bookChapters.$inferSelect;
export type InsertBookChapter = typeof bookChapters.$inferInsert;

/**
 * Daily inspirations (rotating questions)
 */
export const dailyInspirations = mysqlTable("daily_inspirations", {
  id: int("id").autoincrement().primaryKey(),
  question: text("question").notNull(),
  category: varchar("category", { length: 100 }),
  order: int("order").default(0).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type DailyInspiration = typeof dailyInspirations.$inferSelect;
export type InsertDailyInspiration = typeof dailyInspirations.$inferInsert;

/**
 * Question boxes (4 caixinhas de perguntas)
 */
export const questionBoxes = mysqlTable("question_boxes", {
  id: int("id").autoincrement().primaryKey(),
  box: int("box").notNull(), // 1, 2, 3, 4
  boxName: varchar("boxName", { length: 100 }).notNull(), // "Comece Por Aqui", etc
  number: int("number").notNull(), // número da pergunta dentro da caixinha
  question: text("question").notNull(),
  categoryId: int("categoryId"), // Categoria pré-definida para esta pergunta
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type QuestionBox = typeof questionBoxes.$inferSelect;
export type InsertQuestionBox = typeof questionBoxes.$inferInsert;

/**
 * Kits (shared memory projects)
 */
export const kits = mysqlTable("kits", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(), // "Memórias da Vovó Maria"
  description: text("description"),
  ownerUserId: int("ownerUserId").notNull(), // Quem comprou o kit
  activatedAt: timestamp("activatedAt"),
  memoryPeriodEndDate: timestamp("memoryPeriodEndDate"), // 3 meses para enviar memórias
  bookFinalizationEndDate: timestamp("bookFinalizationEndDate"), // 1 ano para finalizar livro
  bookProcessingStarted: boolean("bookProcessingStarted").default(false).notNull(),
  bookReadyForReview: boolean("bookReadyForReview").default(false).notNull(),
  bookApproved: boolean("bookApproved").default(false).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Kit = typeof kits.$inferSelect;
export type InsertKit = typeof kits.$inferInsert;

/**
 * Kit members (shared access to a kit)
 */
export const kitMembers = mysqlTable("kit_members", {
  id: int("id").autoincrement().primaryKey(),
  kitId: int("kitId").notNull(),
  userId: int("userId").notNull(),
  role: mysqlEnum("role", ["owner", "collaborator", "viewer"]).default("collaborator").notNull(),
  invitedBy: int("invitedBy"), // User ID who invited this member
  invitedAt: timestamp("invitedAt").defaultNow().notNull(),
  acceptedAt: timestamp("acceptedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type KitMember = typeof kitMembers.$inferSelect;
export type InsertKitMember = typeof kitMembers.$inferInsert;
